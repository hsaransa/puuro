modules = std.assoc;
sources = std.assoc;

std.type.set_method 'module_source
{<std m src>
    sources.set m src;
};

std.type.set_method 'module
{<std m code>
    (modules.has m).then { raise (exception 'bad_module "already exists") };

    mod = [[] \n];

    f = code.call_frame;
    f.scope.set_local 'pollute {<name obj>
        mod.first.append [name obj];
    };
    f.execute;

    modules.set m mod;
};

std.type.set_method 'require
{<std *mods>
    f = std.active_frame.caller;

    mods.each {<m>
        (modules.has m).else {
            (sources.has m).else {
                raise (exception 'bad_module m);
            };

            execute \t (sources.get m);
        };

        module = modules.get m;
        module.first.each {<x>
            f.scope.set_local x.first x.second;
        };
    };
};
